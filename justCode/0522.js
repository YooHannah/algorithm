/**
 * 给你一个字符串数组，每个字符串代表一种目录结构,每一层用\分割
 * 请将所有目录按以下规则打印出来
 * 子目录直接列在父目录下面
 * 并比父目录向右进两格
 * 同一级的需要按字母顺序排列，不能乱
 * 例如： ['b\cst', 'd\\', 'a\d\e', 'a\b\e']
 * 打印结果
 * a
 *   b
 *     c
 *   d
 *     e
 * b
 *   cst
 * d
 * 
 * 思路：
 * 使用前缀树
 * 构建树的时候，将路径指向的结点也标识成path上的名称
 * 并在父节点存储map结构，用于判断是否已经有该path,用于按顺序打印
 * 然后深度优先遍历
 * 每多一层，多加俩空格
 * 
 */


/**
 * 双向链表结构如果把last认为是left,next是right的话，可以看做是和二叉树一样的结构
 * 给定一个搜索二叉树的头结点head, 请转化成一条有序的双向链表，并返回双向链表的头结点
 * 
 * 思路：
 * 使用二叉树经典递归套路
 * 拿到左右子树的转化结果
 * 然后将左树next指向父节点，父节点last指向左树
 * 父节点next指向右树，右树last指向父节点
 */

/**
 * 找到一颗二叉树中最大的搜索二叉子树，返回最大搜索二叉子树的节点个数和头结点
 * 
 * 思路：
 * 同样递归套路
 * 根据左右子树返回结果
 * 返回结果包含是否是搜索树，最大搜索树头结点head和结点个数size，节点最大最小值
 * 判断是否能跟父节点形成搜索树
 * 同时更新返回结果
 * 
 * 如果左右子树都不是null
 * 则拿二者中size较大的更新head和size
 * 
 * 如果二者中有null或者是可以形成搜索树的情况
 * 则判断是都能跟父node形成搜素树，如果能，更新返回值
 * 
 */

/**
 * 一个帖子最高分数定义为用户所有打分记录中，连续打分数据之和的最大值
 * 计算一个帖子曾经得到过的最高分数为多少
 * 例如，打分记录为：[1,1,-1,-10,11,4,-6,9,20,-10,-2]
 * 最高分为11 + 4 + (-6) + 9 + 20 = 38
 * 
 * 思路：
 * 相当于寻找数组中累计和最大右最长的子数组
 * 假设该子数组位于i-j这一段
 * 那么可以推断
 * i < curr < j ,i ~ curr这段和肯定大于0
 * curr < i -1, curr ~ i-1 这段和肯定小于0
 * 
 * 那么定义两个变量currSum 和maxSum
 * currSum是持续累加和
 * 如果maxSum小于currSum就把maxSum = currSum
 * 如果当前currSum小于0，就置为0，说明之前的累加和小于0，从现在开始重新累加
 * 如果不小，就保持不动
 */

 /**
  * 给定一个整型矩阵，返回子矩阵中最大累计和
  * 
  * 思路：
  * 使用压缩矩阵成数组的思路
  * 假如现在有一个8 * 9 矩阵
  * 依次计算出
  * 0 ~ 0
  * 0 ~ 1  
  * 0 ~ 2
  * ...
  * 2 ~ 8
  * ...
  * 8 ~ 8
  * 这些行组成的矩阵的累计和
  * 只有一行，累计和即为各位置上的原有数字，转成数组累计和
  * 多行则是相同col位置上累计和，再转成数组累计和
  * 每种情况算出累计和最大值后，从中找大小
  */

  /*********************************************************** */

  /**
   * 现有一个数组arr，表示一条路需要照明的情况，
   * 每个元素不是'.' 就是'x', '.' 表示需要照明的地方，'X' 表示不需要，灯也照不到
   * 假如一个路灯放在poi位置，那么它可以照亮poi -1 ,poi, poi+1三个袁元素
   * 如果他们三个都是‘.’的话
   * 
   * 求问这条路需要多少路灯
   * 
   * 思路：
   * 判断当前元素是‘.’ 还是‘x’
   * 如果是x, 继续往后遍历
   * 如果是.，路灯数加1
   * 判断往后一个有没有越界
   * 越界的话，停止
   * 
   * 如果没有越界
   * 判断是x还是.
   * 假如现在位于curr
   * 如果是x,越过x 继续遍历, 相当于从curr + 2继续
   * 如果是., 连续越过两个，继续遍历 相当于从curr + 3继续
   * 因为如果是.,说明现在有两个. 连续，第三个元素无论是x还是. 
   * 都会需要一盏灯，然后从这组需要灯的位置继续往后
   * 
   * 
   */

   /**
    * 已知一个二叉树的中序和先序遍历，求后序遍历顺序，二叉树没有重复的值
    * 
    *
    * 例如 
    * pre = [1,2,4,5,3,6,7]
    * in = [4,2,5,1,6,3,7]
    * 返回
    * [4.5,2,6,7,3,1]
    * 
    * 思路：
    * 根据pre[0]可以知道后序遍历的最后一个值
    * 根据pre[0]在in中的位置划分出左子树元素集合leftInList和右子树元素rightInList
    * 根据二者长度，在in中截出左右子树先序的结果leftPreList和rightPreList
    * 
    * 使用上述方法
    * 然后根据leftInList 和leftPreList 得出左树后序顺序
    * rightInList和rightPreList得出右树后序顺序
    * 
    * 最后进行拼接
    * 
    */

  /**
   * 将数字转化成中英文表达
   * 例如，
   * 17 => 十七，
   * 117 =>一百一十七
   * 21,230,123,456 => 21 Billion 230Million 123 Thousand 456
   */

  /**
   * 求完全二叉树节点个数
   */

  
   /**
    * 求最长递增子序列
    * 
    */

  /**
   * 现在有一这样规律的数组
   * [1,12,123,1234,...12345678910,1234567891011,...]
   * 求问从第i个元素到第r个元素中有多少个数能够被3整除
   * 
   * 思路：
   * 考虑到可以使用的最大数字，所以不能单纯的用相应位置上的数据直接去对3取余
   * 一个数能不能被3整除，等价于一个数上的每位之和能否被3整除
   * 假如当前元素位于n位置，那么这个数能否被整除可以这样计算
   * (n*(n+1)/2)%3
   */

  /************************************************* */


  /**
   * 给定一个数组A，长度n,有1<=A[i]<=n,且位于[1,n]的整数，
   * 其中部分整数会重复出现而部分不会出现
   * 找出[1,n]中所有未出现在A中的整数
   * 
   * 思路：
   * 尽可能的让i位置上的数据等于i+1,那么i位置上不等于i+1的数据就是没有出现过的数据
   */

  /**
   * 现有一土豪想给主播冲人气从start刚好到达end,
   * 冲人气的方式有一下三种
   * a.点赞 花费x 个C币， 人气 +2
   * b.送礼 花费y 个C币，人气 * 2
   * c.私聊 花费z 个C币，人气 - 2
   * 其中end远大于start,且二者均为偶数
   * 求出土豪至少要花多少C币实现目的
   * 
   * 思路：
   * 递归
   * 分别用三种方式增加一次人气值后剩下的人气值如何增加的方式相加
   * 但是要注意边界条件
   * 从start到end过程，人气和花费C币数量都会递增，
   * 很有可能不会刚刚好到达end,
   * 那么要限制一下增加到多少不再尝试
   * 
   */


   /***
    * 现在输入一些数据，表示运营活动的相关情况
    * 主播可以从任意活动开始，但是一定要将关联的后续活动参加完
    * 
    * 例如
    * 
    * 8 10
    * 3 2000 0 1 1 0 0 0 0 0
    * 3 4000 0 0 0 1 1 0 0 0
    * 2 2500 0 0 0 1 0 0 0 0
    * 1 1600 0 0 0 0 1 1 1 0
    * 4 3800 0 0 0 0 0 0 0 1
    * 2 2600 0 0 0 0 0 0 0 1
    * 4 4000 0 0 0 0 0 0 0 1
    * 3 3500 0 0 0 0 0 0 0 0
    * 
    * 第一行N和D，表示一共有N项活动，D表示活动周时长
    * 0 < N <= 1000, 0 < D <= 10000
    * 第1 ~ N + 1行描述每一个活动的信息
    * 第一项表示参加活动需要时间
    * 第二项表示将来可得报酬
    * 之后的每一项表示和活动周内活动的关联关系
    * 1表示有关联，0 表示没有关联
    * 
    * 例子中表示的活动从上到下标记为1 - 8
    * 活动间关系如下
    *       2  -       5
    *    /      \    /    \
    * 1            4 - 6  - 8
    *    \      /    \    /
    *       3          7
    * 
    * 互动由标记数字少的的指向数字大的
    * 问一个主播从哪个活动开始直到完成最后一个活动，也就是活动8
    * 能够获得最多报酬，且最少用时
    * 
    * 思路：
    * 反正都要完成最后一个任务，那就从最后一个任务往回走开始计算
    * 在每个活动结点维持一个天数-报酬Map结构
    * 表示通过不同路径过来的情况下，累计活动天数可以拿到的报酬
    * 全都遍历完后，计算每个结点下面Map表中找到天数最少报酬最多的一条数据
    * 每个结点拿到后再做一次比较，找天数最少报酬最多的
    * 
    * 同级结点不在计算过程中仅保留天数少报酬多的情况是防止在遍历过程中出现
    * 在当前路径累计报酬少，但是再往上面一个报酬多的情况，
    * 因为移除报酬少的数据意味着不再继续一条路线的探索
    */

    /**
     * 给定一个只由数字0和1，逻辑符号 & (与) | (或) 和 ^ (异或) 五种字符组成的字符串express
     * 再给定一个bool类型期待值desired，返回express能有多少种组合方式可以达到desired的结果
     * 举例：
     * express = "1^0|0|1".desired = false
     * 只有"1^（（0|0）|1）" 和 "1^（0|（0|1））" 两种组合可以得到false,返回2
     * express = "1".desired = false
     * 无组合，返回0
     * 
     */

     /**
      * 在一个字符串中找到没有重复字符子串中最长的长度
      * 
      * 例如
      * abcabccbb 最长子串是abc,长度是3
      * 
      * 思路：
      * 子串要连续
      * 遍历每个字符，当前字符位置是i,找
      * 到0 - i-1范围内离i最近的和i位置字符相同的字符位置
      * 而二者之间的距离就是不重复子串的长度
      * 每个字符都得到后找最大的长度
      * 优化：利用i-1位置长度，看位置i字符是否在该范围内
      */

/**
 * 给定两个字符str1和str2,
 * 再给定三个整数，ic,dc,rc、
 * 分别代表插入，删除，替换一个字符的代价
 * 返回将str1转换成str2的最小代价
 * 
 */

/**
 * 给定一个全是小写字母的字符串str
 * 删除多余字符，是的每个字符只保留一个
 * 并让最终结果字符串的字典序最小
 * 例如
 * str = ‘acbc’,删除掉第一个c,得到‘abc’是所有结果字符串中最小的
 * str = 'dbcacbca',删除第一个b和c,第二个c和a,得到'dabc'
 * 是所有结果字符串中字典序最小的
 */

/**
 * 对26个字母进行升序排列组合最终达到的长度，
 * [a,b,c,...z,ab,ac,ad,...az,bc,bd...bz,...abc,....bcd,...xyz...]
 * 随便输入一个升序组合，求位于该数组的位置
 */

/**
 * 
 */