/**
 * 给你一个字符串数组，每个字符串代表一种目录结构,每一层用\分割
 * 请将所有目录按以下规则打印出来
 * 子目录直接列在父目录下面
 * 并比父目录向右进两格
 * 同一级的需要按字母顺序排列，不能乱
 * 例如： ['b\cst', 'd\\', 'a\d\e', 'a\b\e']
 * 打印结果
 * a
 *   b
 *     c
 *   d
 *     e
 * b
 *   cst
 * d
 * 
 * 思路：
 * 使用前缀树
 * 构建树的时候，将路径指向的结点也标识成path上的名称
 * 并在父节点存储map结构，用于判断是否已经有该path,用于按顺序打印
 * 然后深度优先遍历
 * 每多一层，多加俩空格
 * 
 */


/**
 * 双向链表结构如果把last认为是left,next是right的话，可以看做是和二叉树一样的结构
 * 给定一个搜索二叉树的头结点head, 请转化成一条有序的双向链表，并返回双向链表的头结点
 * 
 * 思路：
 * 使用二叉树经典递归套路
 * 拿到左右子树的转化结果
 * 然后将左树next指向父节点，父节点last指向左树
 * 父节点next指向右树，右树last指向父节点
 */

/**
 * 找到一颗二叉树中最大的搜索二叉子树，返回最大搜索二叉子树的节点个数和头结点
 * 
 * 思路：
 * 同样递归套路
 * 根据左右子树返回结果
 * 返回结果包含是否是搜索树，最大搜索树头结点head和结点个数size，节点最大最小值
 * 判断是否能跟父节点形成搜索树
 * 同时更新返回结果
 * 
 * 如果左右子树都不是null
 * 则拿二者中size较大的更新head和size
 * 
 * 如果二者中有null或者是可以形成搜索树的情况
 * 则判断是都能跟父node形成搜素树，如果能，更新返回值
 * 
 */

/**
 * 一个帖子最高分数定义为用户所有打分记录中，连续打分数据之和的最大值
 * 计算一个帖子曾经得到过的最高分数为多少
 * 例如，打分记录为：[1,1,-1,-10,11,4,-6,9,20,-10,-2]
 * 最高分为11 + 4 + (-6) + 9 + 20 = 38
 * 
 * 思路：
 * 相当于寻找数组中累计和最大右最长的子数组
 * 假设该子数组位于i-j这一段
 * 那么可以推断
 * i < curr < j ,i ~ curr这段和肯定大于0
 * curr < i -1, curr ~ i-1 这段和肯定小于0
 * 
 * 那么定义两个变量currSum 和maxSum
 * currSum是持续累加和
 * 如果maxSum小于currSum就把maxSum = currSum
 * 如果当前currSum小于0，就置为0，说明之前的累加和小于0，从现在开始重新累加
 * 如果不小，就保持不动
 */

 /**
  * 给定一个整型矩阵，返回子矩阵中最大累计和
  * 
  * 思路：
  * 使用压缩矩阵成数组的思路
  * 假如现在有一个8 * 9 矩阵
  * 依次计算出
  * 0 ~ 0
  * 0 ~ 1  
  * 0 ~ 2
  * ...
  * 2 ~ 8
  * ...
  * 8 ~ 8
  * 这些行组成的矩阵的累计和
  * 只有一行，累计和即为各位置上的原有数字，转成数组累计和
  * 多行则是相同col位置上累计和，再转成数组累计和
  * 每种情况算出累计和最大值后，从中找大小
  */

  /*********************************************************** */

  /**
   * 现有一个数组arr，表示一条路需要照明的情况，
   * 每个元素不是'.' 就是'x', '.' 表示需要照明的地方，'X' 表示不需要，灯也照不到
   * 假如一个路灯放在poi位置，那么它可以照亮poi -1 ,poi, poi+1三个袁元素
   * 如果他们三个都是‘.’的话
   * 
   * 求问这条路需要多少路灯
   * 
   * 思路：
   * 判断当前元素是‘.’ 还是‘x’
   * 如果是x, 继续往后遍历
   * 如果是.，路灯数加1
   * 判断往后一个有没有越界
   * 越界的话，停止
   * 
   * 如果没有越界
   * 判断是x还是.
   * 假如现在位于curr
   * 如果是x,越过x 继续遍历, 相当于从curr + 2继续
   * 如果是., 连续越过两个，继续遍历 相当于从curr + 3继续
   * 因为如果是.,说明现在有两个. 连续，第三个元素无论是x还是. 
   * 都会需要一盏灯，然后从这组需要灯的位置继续往后
   * 
   * 
   */

   /**
    * 已知一个二叉树的中序和先序遍历，求后序遍历顺序，二叉树没有重复的值
    * 
    *
    * 例如 
    * pre = [1,2,4,5,3,6,7]
    * in = [4,2,5,1,6,3,7]
    * 返回
    * [4.5,2,6,7,3,1]
    * 
    * 思路：
    * 根据pre[0]可以知道后序遍历的最后一个值
    * 根据pre[0]在in中的位置划分出左子树元素集合leftInList和右子树元素rightInList
    * 根据二者长度，在in中截出左右子树先序的结果leftPreList和rightPreList
    * 
    * 使用上述方法
    * 然后根据leftInList 和leftPreList 得出左树后序顺序
    * rightInList和rightPreList得出右树后序顺序
    * 
    * 最后进行拼接
    * 
    */

  /**
   * 将数字转化成中英文表达
   * 例如，
   * 17 => 十七，
   * 117 =>一百一十七
   * 21,230,123,456 => 21 Billion 230Million 123 Thousand 456
   */

  /**
   * 求完全二叉树节点个数
   */

  
   /**
    * 求最长递增子序列
    * 
    */

  /**
   * 现在有一这样规律的数组
   * [1,12,123,1234,...12345678910,1234567891011,...]
   * 求问从第i个元素到第r个元素中有多少个数能够被3整除
   * 
   * 思路：
   * 考虑到可以使用的最大数字，所以不能单纯的用相应位置上的数据直接去对3取余
   * 一个数能不能被3整除，等价于一个数上的每位之和能否被3整除
   * 假如当前元素位于n位置，那么这个数能否被整除可以这样计算
   * (n*(n+1)/2)%3
   */