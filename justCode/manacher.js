/**
 * Manacher 算法解决的问题
 * 字符串str中，最长回文子串的长度如何求解?
 * 如何做到时间按复杂度O(N)实现？
 * 
 * 思路一:
 * 
 * 先将源字符串用#符号做间隔，去除掉回文字符串是奇偶不同情况的判断
 * 例如 
 * 6312187中121 是回文字符串，只需要依次判断当前字符左右两边字符是否相等
 * 63122187中1221 也是回文字符串， 12 和 21 之间没有其他字符来充当中间值作为边界进行判断
 * 但是如果将
 * 6312187 => #6#3#1#2#1#8#7# 这样对于121 判断时，2 对应的回文长度会变成5 5/2 向上取整就是原来长度3
 * 63122187 => #6#3#1#2#2#1#8#7# 这样对于1221 判断时，#可以做间隔 对应的回文长度会变成7，7/2 向上取整就是原来的4
 * 
 * # 符号并不会参与到与原来的字符的对比中，因为#总是在原来字符两侧，
 * 自己会跟自己比较，所以不会影响到原来字符的比较逻辑
 * 
 * 但无法满足时间复杂度O(N),这里的时间复杂度是O(N^2)
 * 
 * 思路二：
 * 在思路一的基础上，利用已经获取到的之前的字符的回文信息，加速当前字符的判断
 * 设置变量
 * R 当前遍历到的字符中向右最远的回文字符的边界后面一个位置
 * 例如 #6#3#1#2#1#8#7# ，当遍历到2时，R 就是 11, 8的位置
 * C 当前R 对应的当时的字符所在位置，就是2所在的位置 8，
 * pArr[], 用于存放已经遍历过的字符身处的回文字符串的长度
 * 
 * 加入当前遍历 到位置i i 位于 c  和 r 之间
 * L+1  i'      C        i   R-1
 * i' 是i相对C对称的位置，L是R 相对C对称的位置
 * 利用对称位置关系，我们至少可以获取到i到R-1的字符 和 L+1 到i' 的字符是相对C 对称的
 * 那么
 * 1. 如果i' 的回文长度半径小于L到i' 的距离，即i'的回文字符串落在了C的回文字符串范围内
 *    那么i 所在的回文字符串也应该是会落在L-R之间的而且长度跟i'相同
 * 2. 如果i' 的回文长度半径大于L到i' 的距离，即i'的回文字符串部分落在了C的回文字符串范围内
 *    i' 回文字符串的左边界在L的左边，那么i' 的回文区域就是R相对于i 对称的R‘位置到R的范围
 *    证明： 
 *    L[L+1  i’  L+1']Y  C  Z[R-1' i  R-1]R
 *    Y和Z 相对于C 对称, L和Y相对于i'对称，假如Z和R相对于i对称，
 *    那么C的回文区域应该是当前L+1到R-1 同时再往左右走一位，所以Z 不应该等于R
 *    所以i的回文区域就是R-1' 到R -1 范围内
 * 3. 如果i' 的回文长度半径等于于L到i' 的距离，即，i‘的左边界和C的左边界压边了，
 *    那么在获取到最小范围后，继续进行暴力递归
 * 
 */

 const manacherString = str => `#${str.split('').join('#')}#`;

 const maxLcpStringLength = str => {
   if (!str) {
     return '输入非法';
   }
   // 在字符串中插入#
   const list = manacherString(str);
   let c = -1; // 对称中心点
   let r = -1; // 当前回文最右边界+1
   let max = Number.MIN_VALUE; // 回文字符串最长长度
   let pArr = []; // 每个字符所在回文半径
   const { length } = list;
   for (let i = 0; i<length; i++) {
     // 获取可能的最小回文长度
     // pArr[2 * c - i] i 相对于c 对称位置的回文半径
     // r-i 当前位置到当前回文最右边界距离，相当于在判断 1，2 ，3 两种情况
     // 如果i 在r外面，即大于r,则直接暴力查找初始值为1；
     pArr[i] = r > i ? Math.min(pArr[2 * c - i] || 1, r -i)  : 1;
     // 在拿到最小可能回文后，尝试向两边扩
     // i + pArr[i] 向右移不能超过字符长度
     // i - pArr[i] 向左移不能超过字符长度
     while (i + pArr[i] < length && i - pArr[i] > -1) {
       const distance = pArr[i];
       if (list[i - distance] === list[i + distance]) {
         pArr[i]++
       } else {
         break
       }
     }
     // 如果扩完右边界大于当前最右边界r, 更新 r 和 c
     if(i + pArr[i] > r) {
       r = i + pArr[i];
       c = i;
     }
     max = Math.max(max, pArr[i]) // 因为有插入#,所以半径就是原字符回文长度
   }
   return max - 1;
 }


/**
 * 由一个代表题目，引出一种结构
 * 
 * 【题目】
 * 
 * 有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边，
 * 窗口每次向右边滑动一个位置
 * 
 * 例如，数组[4,3,5,4,3,3,6,7],窗口大小为3时：
 * [4,3,5],4,3,3,6,7 最大值5
 * 4,[3,5,4],3,3,6,7 最大值5
 * 4,3,[5,4,3],3,6,7 最大值5
 * 4,3,5,[4,3,3],6,7 最大值4
 * 4,3,5,4,[3,3,6],7 最大值6
 * 4,3,5,4,3,[3,6,7] 最大值7
 * 
 * 如果数组长度为n, 窗口大小为w,那么将会产生n-w+1个窗口的最大值
 * 实现函数，输入为整型数组，窗口大小为w
 * 输出长度n-w+1的数组res，res[i] 代表第i个窗口里面的最大值
 */


/**
 * 单调栈结构
 * 
 * 在数组中相找到一个数，左边和右边比这个数小，且离这个数最近的位置
 * 如果对每个数都像求这样的信息，能不能整体代价达到O(N)
 */

/**
 * 树型dp套路
 * 
 * 树型dp套路使用前提:
 * 如果题目求解目标是S规则，则求解流程可以定成以每一个节点的子树在S规则下的每一个答案，
 * 并且最终答案一定在其中
 * 
 * 步骤：
 * 1. 以某个节点X为头节点的子树中，分析答案有哪些可能性，
 *    并且这种分析师以X的左子树，X的右子树和X的整颗树的角度来考虑可能性的
 * 2. 根据第一步的可能性，列出所有需要的信息
 * 3. 合并第二步的信息，对左右子树提出同样的要求，并写出信息结构
 * 4. 设计递归函数，递归函数是处理以X为头节点的情况下的答案
 *    包括设计递归的basecase,默认直接得到左右子树的所有信息，以及把可能性做整合，
 *     并且要返回第三步的信息结构
 */

/**
 * 【题目】二叉树节点间的最大距离问题
 * 
 * 从二叉树的结点a出发，可以向上或者向下走，但沿途的节点只能经过一次，
 * 到达节点b时路径上的节点个数叫做a到b的距离，那么二叉树任何两个节点之间都有距离
 * 求整颗树上的最大距离
 * 
 */

/**
 * 【题目】派对最大快乐值
 *  员工的信息定义如下：
 *  class Employee {
 *    int happy; // 员工可以带来的欢乐值
 *    list subordinates; // 这名员工有哪些直接下级
 *   }
 * 公司的每个员工都符合类的描述，整个公司结构可以看做是一颗标准的，没有环的多叉树
 * 树的头结点是公司唯一的老板，除老板之外的每个员工都有唯一的直接上级，
 * 叶结点是没有任何下属的基层员工(subordinates), 除基层员工外，每个员工都有一个或多个直接下级
 * 
 * 公司现在要办party,你可以决定哪些员工来，哪些员工不来，但要遵循如下规则
 * 1. 如果某个员工来了，那么这个员工的所有直接下级都不能来
 * 2. 派对的整体快乐值是所有到场员工的快乐值和
 * 3. 你的目标是让派对的快乐值最大
 * 
 * 给定这棵树的头结点，求最大快乐值
 */


/**
 * Morris 遍历
 * 一种遍历二叉树的方式，并且时间复杂度O(N), 额外空间复杂度O(1)
 * 通过利用树中大量空闲的指针的方式，达到节省空间的目的
 * 
 * 细节：假设来到当前节点cur,开始时cur来到头结点位置
 * 1. 如果cur没有左孩子，cur向右移动，cur = cur.right
 * 2. 如果cur有左孩子，找到左子树上最右的节点mostright
 *    如果mostright的右指针指向空，让其指向cur，然后cur向左移动 cur = cur.left
 *    如果mostright的右指针指向cur,让其指向null, 然后cur向右移动 cur = cur.right
 * 3. cur 为空时遍历停止
 */