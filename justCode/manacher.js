/**
 * Manacher 算法解决的问题
 * 字符串str中，最长回文子串的长度如何求解?
 * 如何做到时间按复杂度O(N)实现？
 * 
 * 思路一:
 * 
 * 先将源字符串用#符号做间隔，去除掉回文字符串是奇偶不同情况的判断
 * 例如 
 * 6312187中121 是回文字符串，只需要依次判断当前字符左右两边字符是否相等
 * 63122187中1221 也是回文字符串， 12 和 21 之间没有其他字符来充当中间值作为边界进行判断
 * 但是如果将
 * 6312187 => #6#3#1#2#1#8#7# 这样对于121 判断时，2 对应的回文长度会变成5 5/2 向上取整就是原来长度3
 * 63122187 => #6#3#1#2#2#1#8#7# 这样对于1221 判断时，#可以做间隔 对应的回文长度会变成7，7/2 向上取整就是原来的4
 * 
 * # 符号并不会参与到与原来的字符的对比中，因为#总是在原来字符两侧，
 * 自己会跟自己比较，所以不会影响到原来字符的比较逻辑
 * 
 * 但无法满足时间复杂度O(N),这里的时间复杂度是O(N^2)
 * 
 * 思路二：
 * 在思路一的基础上，利用已经获取到的之前的字符的回文信息，加速当前字符的判断
 * 设置变量
 * R 当前遍历到的字符中向右最远的回文字符的边界后面一个位置
 * 例如 #6#3#1#2#1#8#7# ，当遍历到2时，R 就是 11, 8的位置
 * C 当前R 对应的当时的字符所在位置，就是2所在的位置 8，
 * pArr[], 用于存放已经遍历过的字符身处的回文字符串的长度
 * 
 * 加入当前遍历 到位置i i 位于 c  和 r 之间
 * L+1  i'      C        i   R-1
 * i' 是i相对C对称的位置，L是R 相对C对称的位置
 * 利用对称位置关系，我们至少可以获取到i到R-1的字符 和 L+1 到i' 的字符是相对C 对称的
 * 那么
 * 1. 如果i' 的回文长度半径小于L到i' 的距离，即i'的回文字符串落在了C的回文字符串范围内
 *    那么i 所在的回文字符串也应该是会落在L-R之间的而且长度跟i'相同
 * 2. 如果i' 的回文长度半径大于L到i' 的距离，即i'的回文字符串部分落在了C的回文字符串范围内
 *    i' 回文字符串的左边界在L的左边，那么i' 的回文区域就是R相对于i 对称的R‘位置到R的范围
 *    证明： 
 *    L[L+1  i’  L+1']Y  C  Z[R-1' i  R-1]R
 *    Y和Z 相对于C 对称, L和Y相对于i'对称，假如Z和R相对于i对称，
 *    那么C的回文区域应该是当前L+1到R-1 同时再往左右走一位，所以Z 不应该等于R
 *    所以i的回文区域就是R-1' 到R -1 范围内
 * 3. 如果i' 的回文长度半径等于于L到i' 的距离，即，i‘的左边界和C的左边界压边了，
 *    那么在获取到最小范围后，继续进行暴力递归
 * 
 */

 const manacherString = str => `#${str.split('').join('#')}#`;

 const maxLcpStringLength = str => {
   if (!str) {
     return '输入非法';
   }
   // 在字符串中插入#
   const list = manacherString(str);
   let c = -1; // 对称中心点
   let r = -1; // 当前回文最右边界+1
   let max = Number.MIN_VALUE; // 回文字符串最长长度
   let pArr = []; // 每个字符所在回文半径
   const { length } = list;
   for (let i = 0; i<length; i++) {
     // 获取可能的最小回文长度
     // pArr[2 * c - i] i 相对于c 对称位置的回文半径
     // r-i 当前位置到当前回文最右边界距离，相当于在判断 1，2 ，3 两种情况
     // 如果i 在r外面，即大于r,则直接暴力查找初始值为1；
     pArr[i] = r > i ? Math.min(pArr[2 * c - i] || 1, r -i)  : 1;
     // 在拿到最小可能回文后，尝试向两边扩
     // i + pArr[i] 向右移不能超过字符长度
     // i - pArr[i] 向左移不能超过字符长度
     while (i + pArr[i] < length && i - pArr[i] > -1) {
       const distance = pArr[i];
       if (list[i - distance] === list[i + distance]) {
         pArr[i]++
       } else {
         break
       }
     }
     // 如果扩完右边界大于当前最右边界r, 更新 r 和 c
     if(i + pArr[i] > r) {
       r = i + pArr[i];
       c = i;
     }
     max = Math.max(max, pArr[i]) // 因为有插入#,所以半径就是原字符回文长度
   }
   return max - 1;
 }



