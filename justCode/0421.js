
 /**
  * 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作
  * 要求：
  * 1. pop, push，getMin操作的时间复杂度都是O(1)
  * 2. 设计的栈类型可以使用现成的栈结构
  * 
  * 思路：
  * 准备两个栈，一个用来装用户数据，另外一个用来装当前整个栈中最小值
  * 在push数据的时候，如果push的数据比当前最小值栈顶小，
  * 它就变成栈中最小值push到最小值栈中
  * 如果不小于最小值栈顶，那么push栈顶到最小值栈中
  * 这样每次获取最小值，直接到最小值栈中获取即可
  */

/**
 * 如何仅用队列结构实现栈结构？
 * 
 * 思路：用两个队列
 * 第一个队列用来装用户push的数据
 * 当用户想pop时，将第一个队列中除了最后一个进入的以外，全部push到第二个队列
 * 再对第一个队列进行pop,返回
 * 如果第一个队列是空，那么，挪第二个队列剩一个，pop出来返回
 * 
 * 如何仅用栈结构实现队列结构？
 * 
 * 思路： 
 * 用两个栈，一个栈装push的数据，
 * 另一个栈在pop时，将第一个栈中数据pop出来装起来，形成逆序的数据再pop
 * 
 * 
 * 实践应用题目：
 * 用栈实现一个图的宽度优先遍历： 利用两个栈导成队列结构
 * 用队列实现一个图的深度优先遍历： 利用两个队列导成栈结构
 */
const 



/**
 * 动态规划的空间压缩技巧
 * 
 * 主要思想就是尝试用数组动态存放矩阵形成的结果
 * 
 * 矩阵下一行的值如果只跟上一行或者下一行的值有关，那么可以准备一个数组依次存放原来矩阵数据
 * 如果不仅依赖挨着的行，还依赖往上或者往下多行，那要准备多个一维数组，存放依赖的每行数据，用于计算下一行数据
 * 如果矩阵是3维度的,xyz型的，那就准备一个二维矩阵表示当前层，由当前层数据算出下一层数据，道理一样
 * 
 */

/**
 * 给你一个二维数组，其中每个数都是正数，要求从左上角到右下角，
 * 每一步只能向右或者向下，沿途经过的数字要累加起来，
 * 最后请返回最小的路径和
 * 
 * 
 */

const process = (i,j,m,n, arr) => {
  if ( i > m || j > n) {
    return Number.MAX_SAFE_INTEGER;
  }
  if(i + 1 === m && j === n || i === m && j + 1 === n) {
    return arr[i][j];
  }
  return arr[i][j] + Math.min(process(i+1, j, m,n,arr), process(i,j+1,m,n,arr));
}

/**
 * 给定一个数组arr,已知其中所有的值都是非负的，
 * 将这个数组看作一个容器，请返回容器能装多少水
 * 
 * 例如：
 * arr = [3,1,2,5,2,4],根据值画出的直方图就是容器形状，
 * 该容器可以装下5格水
 *            ____
 *            |5 |  _____
 *  ___       |  |  | 4 |         
 *  |3 |   ___|  |__|   |
 *  |  |___|2 |  |2 |   |
 *  |  | 1 |
 * 
 * 3125组成的凹陷处可储存3格水
 * 524组成的凹陷处可储存2格水
 * arr = [4,5,1,3,2],根据值画出的直方图就是容器形状，
 * 该容器可以装下2格水
 * 
 * 思路：
 * 求解每个柱子上方可容纳水的体积然后求和
 * 每个柱子上方可容纳水的体积等于其min(左柱子max, 右柱子max) - 当前柱子值
 * 假设结果是负值，说明当前柱子比左右两边所有柱子都高，那他上方无法存储水分，就是0
 */

const getVolumnOfWater = (arr) => {
  let volumn = 0;
  arr.forEach((col, index) => {
    if (index === 0 || index === arr.length -1) {
      volumn += 0;
    } else {
      const leftMax = arr.slice(0, index).sort((a,b) => b-a)[0];
      const rightMax = arr.slice(index+1).sort((a,b) => b-a)[0];
      volumn += Math.max(Math.min(leftMax, rightMax) - col, 0);
    }
  });
  return volumn
}

/**
 * 给定一个数组arr长度为N，你可以把任意长度大于0且小于N的前缀作为左部分
 * 剩下的作为右部分，但是每种划分下都有左部分的最大值和右部分的最大值，
 * 请返回最大的，左部分最大值减去右部分最大值的绝对值，
 * 假设没有重复，都是正数
 * 
 * 思路：
 * 整个数组会有一个最大值，这个最大值被划分到哪部分就是哪部分的最大值
 * 假如最大值划到左部分
 * 右部分必须要至少有一个值，那个最右边的那个值无论什么时候都要被划分到右部分
 * 假如右部分的其他值有比最右值大的数，那么他就不是右部分最大值
 * 但是要求的差值绝对值会变小
 * 如果右部分没有比最右值大的，那么最右值就是右部分最大值
 * 所以结果就是让数组总体最大值减去最右值
 * 划到右部分同理
 * 
 */
const maxAbs = arr => {
  const left = arr[0];
  const right = arr[arr.length -1];
  const max = arr.sort((a,b) => b-a)[0];
  return Math.max(Math.abs(max-right), Math.abs(max-left));
}

/**
 * 如果一个字符串为str,把字符串的前面任意部分挪到后面形成的字符叫做str的旋转词
 * 比如
 * str = '12345',
 * 它的旋转词有‘23451’， ‘34512’，‘45123’ 和‘51234’
 * 
 * 现给定两个字符串a和b，请判断a和b是否互为旋转词
 * 例
 * a = 'cdab', b = 'abcd' 返回true
 * a = '1ab2', b = 'ab12' 返回false
 * a = '2ab1', b = 'ab12' 返回true
 * 
 * 思路：
 * 将原字符串拼接一个自己形成自己的两倍串，那它所有的旋转词都是他两倍串的子串
 */
const judge = (a,b) => {
  const doubleA = a + a;
  const doubleB = b + b;
  return doubleA.includes(b) && doubleB.includes(a);
}


/**
 * 现在有咖啡机arr=[3,4,5], 每一项代表该咖啡机煮一杯咖啡需要的时间
 * 咖啡杯可以选择可重复利用的和一次性的，
 * 重复利用的咖啡杯需要清洗，洗咖啡杯的机器，只能一次洗一杯，洗一杯的时间是b,
 * 一次性咖啡杯可以自然降解，降解完成的时间是b
 * 先在有N个人需要喝咖啡并需要等咖啡杯清洗完或者降解完,才算完成喝咖啡的事
 * 请算出这帮人全都完成喝咖啡需要的最小用时
 * 
 */

/**
 * 给定一个数组arr,如果通过调整，
 * 可以做到arr中任意两个相邻的数字相乘都是4的倍数
 * 返回true, 如果不能返回false
 */