/**
 * 实现一种狗猫队列的结构，要求如下：
 * add 方法可以将cat 类或者dog 类的实例放入队列中
 * pollAll 方法，可以将队列中所有的实例按照进队列的先后顺序依次弹出
 * pollDog 方法，可以将队列中Dog类按照进队列的先后顺序依次弹出
 * pollDog 方法，可以将队列中Cat类按照进队列的先后顺序依次弹出
 * isEmpyty 方法，可以检查队列中是否还有Dog 或者Cat 的实例
 * isDogEmpyty 方法，可以检查队列中是否还有Dog 类的实例
 * isCatEmpyty 方法，可以检查队列中是否还有Cat 类的实例
 * 
 * 以上所有方法的时间复杂度就是O(1)
 */

 /**
  * 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作
  * 要求：
  * 1. pop, push，getMin操作的时间复杂度都是O(1)
  * 2. 设计的栈类型可以使用现成的栈结构
  * 
  */

/**
 * 如何仅用队列结构实现栈结构？
 * 如何仅用栈结构实现队列结构？
 * 
 * 实践应用题目：
 * 
 */


/**
 * 动态规划的空间压缩技巧
 * 
 * 主要思想就是尝试用数组动态存放矩阵形成的结果
 */

/**
 * 给你一个二维数组，其中每个数都是正数，要求从左上角到右下角，
 * 每一步只能向右或者向下，沿途经过的数字要累加起来，
 * 最后请返回最小的路径和
 */

/**
 * 给定一个数组arr,已知其中所有的值都是非负的，
 * 将这个数组看作一个容器，请返回容器能装多少水
 * 
 * 例如：
 * arr = [3,1,2,5,2,4],根据值画出的直方图就是容器形状，
 * 该容器可以装下5格水
 *            ____
 *            |5 |  _____
 *  ___       |  |  | 4 |         
 *  |3 |   ___|  |__|   |
 *  |  |___|2 |  |2 |   |
 *  |  | 1 |
 * 
 * 3125组成的凹陷处可储存3格水
 * 524组成的凹陷处可储存2格水
 * arr = [4,5,1,3,2],根据值画出的直方图就是容器形状，
 * 该容器可以装下2格水
 * 
 */

/**
 * 给定一个数组arr长度为N，你可以把任意长度大于0且小于N的前缀作为左部分
 * 剩下的作为右部分，但是每种划分下都有左部分的最大值和右部分的最大值，
 * 请返回最大的，左部分最大值减去右部分最大值的绝对值，
 * 假设没有重复，都是正数
 * 
 * 思路：
 * 整个数组会有一个最大值，这个最大值被划分到哪部分就是哪部分的最大值
 * 假如最大值划到左部分
 * 右部分必须要至少有一个值，那个最右边的那个值无论什么时候都要被划分到右部分
 * 假如右部分的其他值有比最右值大的数，那么他就不是右部分最大值
 * 但是要求的差值绝对值会变小
 * 如果右部分没有比最右值大的，那么最右值就是右部分最大值
 * 所以结果就是让数组总体最大值减去最右值
 * 划到右部分同理
 * 
 */
const maxAbs = arr => {
  const left = arr[0];
  const right = arr[arr.length -1];
  const max = arr.sort((a,b) => b-a)[0];
  return Math.max(Math.abs(max-right), Math.abs(max-left));
}

/**
 * 如果一个字符串为str,把字符串的前面任意部分挪到后面形成的字符叫做str的旋转词
 * 比如
 * str = '12345',
 * 它的旋转词有‘23451’， ‘34512’，‘45123’ 和‘51234’
 * 
 * 现给定两个字符串a和b，请判断a和b是否互为旋转词
 * 例
 * a = 'cdab', b = 'abcd' 返回true
 * a = '1ab2', b = 'ab12' 返回false
 * a = '2ab1', b = 'ab12' 返回true
 * 
 * 思路：
 * 将原字符串拼接一个自己形成自己的两倍串，那它所有的旋转词都是他两倍串的子串
 */
const judge = (a,b) => {
  const doubleA = a + a;
  const doubleB = b + b;
  return doubleA.includes(b) && doubleB.includes(a);
}


/**
 * 现在有咖啡机arr=[3,4,5], 每一项代表该咖啡机煮一杯咖啡需要的时间
 * 咖啡杯可以选择可重复利用的和一次性的，
 * 重复利用的咖啡杯需要清洗，洗咖啡杯的机器，只能一次洗一杯，洗一杯的时间是b,
 * 一次性咖啡杯可以自然降解，降解完成的时间是b
 * 先在有N个人需要喝咖啡并需要等咖啡杯清洗完或者降解完,才算完成喝咖啡的事
 * 请算出这帮人全都完成喝咖啡需要的最小用时
 * 
 */

/**
 * 给定一个数组arr,如果通过调整，
 * 可以做到arr中任意两个相邻的数字相乘都是4的倍数
 * 返回true, 如果不能返回false
 */