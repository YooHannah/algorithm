/**0606 */

/**
 * 给定一个数组，求排序之后，相邻两数的最大差值，
 * 要求时间复杂度O(N),且要求不能用基于比较的排序
 * 
 * 思路：
 * 找出最大最小值，涵盖这两值范围，均等10分，形成10个桶
 * 将所有数字放入10个桶中
 * 计算每个桶中最大最小值，
 * 让最大值和下一个桶的最小值求差，
 * 让最小值和上一个桶的最大值求差
 * 从里面找最大值即要求的最大差值
 * 
 * 原理
 * 一个桶里面的数字差肯定小于桶的范围大小，直接忽略不计
 * 从桶之间找最大值
 */

/**
 * 给出n个数字，问最多有多少不重叠的非空区间，使得每个区间内数字的xor都等于0
 * 
 * 
 */

/**
 * 现有n1  + n2 种面值的硬币，
 * 其中n1种为普通币，可以取任意枚，
 * n2种为纪念币，每种最多只能取一枚
 * 每种硬币有一个面值，问能用多少种方法拼出m的面值？
 * 
 * 思路：
 * 预处理一下，先算出只用n1 类型的硬币和只用n2类型硬币，拼出0-m面值的方法数
 * 再用n1 硬币 拼出x面额，有a种方法，
 * 剩下m-x面额用n2硬币拼出有b种方法
 * 所有情况a*b累计和就是最终方法数
 */

/**
 * 
 * 给定两个有序数组A和B，长度分别是m和n
 * 求A和B中最大的K歌数字
 * 要求使用尽量少的比较次数
 * 
 * 思路：
 * 利用一个数组中位数位置，比较大小，算出右边数字个数
 * 和另一个数组大于该中位数的数字个数
 * 加一起是否等于K  
 */

/******************** 0607 ****************/ 
/**
 * 约瑟夫杀人算法变形
 * 每次数的要杀的人是从这一轮开始的那个人拿到的编号
 * 编号是几数几个人
 * 
 * 某公司招聘，有n 个人入围，HR在黑板上写下m个正整数
 * a1,a2,...am
 * 用作n个人循环领取的临时编号
 * n个人原始编号顺序依次是0, 1, ... n-1
 * 现在从原始编号0这个人开始领取临时编号
 * 0到n-1个人领到的临时编号依次是
 * a1,a2,...am, a1,a2,...am,...a(n%m)
 * 都领完后，看原始编号0这个人手上的临时编号a1, 
 * 从原始编号0这个人开始数，输到第a1个人，
 * 把第a1这个人淘汰，假设这个人原始编号是x
 * 下一轮从x+1开始
 * 看x+1手上的临时编号是几，数几个人，然后淘汰，
 * 以此多轮淘汰后，剩一个人，
 * 返回该人的原始编号
 * 
 */

/****** 0608 ******/

/**
 * 给定一个N*3的矩阵matrix,
 * 对于每一个长度为3的小数组arr
 * 都表示一个大楼的3个数据
 * [大楼左边界， 大楼右边界，大楼高度（一定都大于0）]
 * 地基都在X轴上，大楼之间可能会有重叠
 * 请返回整体轮廓线数组
 * 例如，matrix = 
 * [
 *  [2,5,6],
 *  [1,7,4],
 *  [4,6,7],
 *  [3,6,5],
 *  [10,13,12],
 *  [9,11,3],
 *  [12,14,4],
 *  [10,12,5]
 * ]
 * 
 * 返回：
 * [
 *  [1,2,4],
 *  [2,4,6],
 *  [4,6,7],
 *  [6,7,4],
 *  [9,10,3],
 *  [10,12,5],
 *  [12,14,4]
 * ]
 * 
 * 思路：
 * 组装成有序表
 * 将每个子数组拆成两个
 * 原数组[a,b,c]
 * 拆成这样的两个
 * [a,up,c], [b,down,c]，这样数组为描述方便成为边界数组
 * 所有子数组拆完后
 * 按边界数组第一项从小到大排序，up在前，down在后
 * 准备两个有序表，
 * map1: 存放统计的《高度：频次》，相同高度，每遇到一个down边界减1，
 * map2: 存放当统计到当前坐标高度后，《当前坐标: 此时map1中的最大高度值》
 * 统计完后看map2高度变化
 * 假设map2 = {
 *  <1: 4>
 *  <2: 8>
 *  <4: 8>
 *  <3: 8>
 *  <4: 8>
 *  <6: 5>
 *  <7: 0>
 * 
 * }
 * 那么最终返回的结果就是
 * [
 * [1,2,4],
 * [2,4,8],
 * [4,6,5],
 * [6,7,5],
 * ]
 * 
 * 其实map2存放的是当前坐标所处的最大高度
 */


/**
 * 给定一个均为正数无序的数组arr,求数组中所有子数组中相加和为 K 的最长子数组长度
 * 要求时间复杂度O(N),时间复杂度O(1)
 * 
 * 例arr = [1,2,1,1] k = 3 
 * 返回 3
 * 
 * 思路：
 * 使用窗口移动
 * 准备box = [], 存放累计和k的子数组长度的各种情况
 * 开始L = R = i = 0
 * sum = 1， 数组第一个值
 * sum < K， R 右移一个, sum+=arr[++i];
 * 如果sum < k, 继续右移sum+=arr[++i];
 * 如果sum == K, box.push(R -L +1), R 继续右移
 * 如果sum > K, L右移一个，sum = sum - arr[L];
 * 再判断sum与k关系，直到 L= R = arr.length -1;
 * 
 * 找出box最大值返回
 * 
 * 
 */

/**
 * 给定一个正负0都包含的无序数组,
 * 求数组中所有子数组中相加和小于等于 K 的最长子数组长度
 * 
 * 例如arr = [3,-2,-4,0,6],K =2;
 * 相加小于等于2的最长子数组为[3,-2,-4,0],长度为4故返回4
 * 
 * 例如
 * 先从后往前计算一下累计和，如果之前计算的大于0，不累加
 * arr2 =  [-3,-6,-4,0,6]
 * 对应计算的右边界为
 * arr3 = [2,2,2,3,4]
 * 把右边界一样的分成一组，计算累计和
 * [-3, 0, 6]
 * -3 + 0 = -3 <2,所以就是0-3位置上的数加起来小于2
 */

/**
 * 给定一个非负数组，每个位置上代表有几枚铜板
 * a先手b后手，每次都可以拿任意数量铜板，但是不能不拿
 * 谁最先把铜板拿完谁赢，
 * 返回获胜者名字
 */